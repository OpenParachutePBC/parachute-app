// Mocks generated by Mockito 5.4.6 from annotations
// in app/test/core/services/search/search_index_service_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:app/core/services/search/bm25_index_manager.dart' as _i6;
import 'package:app/core/services/search/chunking/recording_chunker.dart'
    as _i7;
import 'package:app/core/services/search/content_hasher.dart' as _i11;
import 'package:app/core/services/search/models/indexed_chunk.dart' as _i4;
import 'package:app/core/services/search/models/vector_search_result.dart'
    as _i5;
import 'package:app/core/services/search/vector_store.dart' as _i2;
import 'package:app/features/recorder/models/recording.dart' as _i8;
import 'package:app/features/recorder/services/storage_service.dart' as _i9;
import 'package:mockito/mockito.dart' as _i1;
import 'package:mockito/src/dummies.dart' as _i10;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: must_be_immutable
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

/// A class which mocks [VectorStore].
///
/// See the documentation for Mockito's code generation for more information.
class MockVectorStore extends _i1.Mock implements _i2.VectorStore {
  MockVectorStore() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<void> initialize() =>
      (super.noSuchMethod(
            Invocation.method(#initialize, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<void> addChunks(List<_i4.IndexedChunk>? chunks) =>
      (super.noSuchMethod(
            Invocation.method(#addChunks, [chunks]),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<bool> removeChunks(String? recordingId) =>
      (super.noSuchMethod(
            Invocation.method(#removeChunks, [recordingId]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> isIndexed(String? recordingId) =>
      (super.noSuchMethod(
            Invocation.method(#isIndexed, [recordingId]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getContentHash(String? recordingId) =>
      (super.noSuchMethod(
            Invocation.method(#getContentHash, [recordingId]),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<void> updateManifest(
    String? recordingId,
    String? contentHash,
    int? chunkCount,
  ) =>
      (super.noSuchMethod(
            Invocation.method(#updateManifest, [
              recordingId,
              contentHash,
              chunkCount,
            ]),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<List<_i5.VectorSearchResult>> search(
    List<double>? queryEmbedding, {
    int? limit = 20,
    double? minScore = 0.0,
  }) =>
      (super.noSuchMethod(
            Invocation.method(
              #search,
              [queryEmbedding],
              {#limit: limit, #minScore: minScore},
            ),
            returnValue: _i3.Future<List<_i5.VectorSearchResult>>.value(
              <_i5.VectorSearchResult>[],
            ),
          )
          as _i3.Future<List<_i5.VectorSearchResult>>);

  @override
  _i3.Future<List<String>> getIndexedRecordingIds() =>
      (super.noSuchMethod(
            Invocation.method(#getIndexedRecordingIds, []),
            returnValue: _i3.Future<List<String>>.value(<String>[]),
          )
          as _i3.Future<List<String>>);

  @override
  _i3.Future<Map<String, dynamic>> getStats() =>
      (super.noSuchMethod(
            Invocation.method(#getStats, []),
            returnValue: _i3.Future<Map<String, dynamic>>.value(
              <String, dynamic>{},
            ),
          )
          as _i3.Future<Map<String, dynamic>>);

  @override
  _i3.Future<void> clear() =>
      (super.noSuchMethod(
            Invocation.method(#clear, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<void> close() =>
      (super.noSuchMethod(
            Invocation.method(#close, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);
}

/// A class which mocks [BM25IndexManager].
///
/// See the documentation for Mockito's code generation for more information.
class MockBM25IndexManager extends _i1.Mock implements _i6.BM25IndexManager {
  MockBM25IndexManager() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get isBuilding =>
      (super.noSuchMethod(Invocation.getter(#isBuilding), returnValue: false)
          as bool);

  @override
  bool get needsRebuild =>
      (super.noSuchMethod(Invocation.getter(#needsRebuild), returnValue: false)
          as bool);

  @override
  _i3.Future<void> ensureIndexReady() =>
      (super.noSuchMethod(
            Invocation.method(#ensureIndexReady, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<void> rebuildIndex() =>
      (super.noSuchMethod(
            Invocation.method(#rebuildIndex, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  void invalidate() => super.noSuchMethod(
    Invocation.method(#invalidate, []),
    returnValueForMissingStub: null,
  );

  @override
  Map<String, dynamic> getStats() =>
      (super.noSuchMethod(
            Invocation.method(#getStats, []),
            returnValue: <String, dynamic>{},
          )
          as Map<String, dynamic>);
}

/// A class which mocks [RecordingChunker].
///
/// See the documentation for Mockito's code generation for more information.
class MockRecordingChunker extends _i1.Mock implements _i7.RecordingChunker {
  MockRecordingChunker() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<List<_i4.IndexedChunk>> chunkRecording(_i8.Recording? recording) =>
      (super.noSuchMethod(
            Invocation.method(#chunkRecording, [recording]),
            returnValue: _i3.Future<List<_i4.IndexedChunk>>.value(
              <_i4.IndexedChunk>[],
            ),
          )
          as _i3.Future<List<_i4.IndexedChunk>>);

  @override
  _i3.Future<List<_i4.IndexedChunk>> chunkRecordings(
    List<_i8.Recording>? recordings,
  ) =>
      (super.noSuchMethod(
            Invocation.method(#chunkRecordings, [recordings]),
            returnValue: _i3.Future<List<_i4.IndexedChunk>>.value(
              <_i4.IndexedChunk>[],
            ),
          )
          as _i3.Future<List<_i4.IndexedChunk>>);
}

/// A class which mocks [StorageService].
///
/// See the documentation for Mockito's code generation for more information.
class MockStorageService extends _i1.Mock implements _i9.StorageService {
  MockStorageService() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get isInitialized =>
      (super.noSuchMethod(Invocation.getter(#isInitialized), returnValue: false)
          as bool);

  @override
  _i3.Future<void> ensureInitialized() =>
      (super.noSuchMethod(
            Invocation.method(#ensureInitialized, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  void forceRefresh() => super.noSuchMethod(
    Invocation.method(#forceRefresh, []),
    returnValueForMissingStub: null,
  );

  @override
  _i3.Future<void> startWatchingFilesystem({void Function()? onChange}) =>
      (super.noSuchMethod(
            Invocation.method(#startWatchingFilesystem, [], {
              #onChange: onChange,
            }),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<void> stopWatchingFilesystem() =>
      (super.noSuchMethod(
            Invocation.method(#stopWatchingFilesystem, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  void setIgnoredRecordingPath(String? path) => super.noSuchMethod(
    Invocation.method(#setIgnoredRecordingPath, [path]),
    returnValueForMissingStub: null,
  );

  @override
  void clearIgnoredRecordingPath() => super.noSuchMethod(
    Invocation.method(#clearIgnoredRecordingPath, []),
    returnValueForMissingStub: null,
  );

  @override
  _i3.Future<void> initialize() =>
      (super.noSuchMethod(
            Invocation.method(#initialize, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<String> getSyncFolderPath() =>
      (super.noSuchMethod(
            Invocation.method(#getSyncFolderPath, []),
            returnValue: _i3.Future<String>.value(
              _i10.dummyValue<String>(
                this,
                Invocation.method(#getSyncFolderPath, []),
              ),
            ),
          )
          as _i3.Future<String>);

  @override
  _i3.Future<bool> setSyncFolderPath(String? path) =>
      (super.noSuchMethod(
            Invocation.method(#setSyncFolderPath, [path]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<List<_i8.Recording>> getRecordings({
    bool? includeOrphaned = false,
  }) =>
      (super.noSuchMethod(
            Invocation.method(#getRecordings, [], {
              #includeOrphaned: includeOrphaned,
            }),
            returnValue: _i3.Future<List<_i8.Recording>>.value(
              <_i8.Recording>[],
            ),
          )
          as _i3.Future<List<_i8.Recording>>);

  @override
  _i3.Future<String?> saveRecording(_i8.Recording? recording) =>
      (super.noSuchMethod(
            Invocation.method(#saveRecording, [recording]),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> updateRecording(_i8.Recording? updatedRecording) =>
      (super.noSuchMethod(
            Invocation.method(#updateRecording, [updatedRecording]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> appendToRecording({
    required String? recordingId,
    required String? newTranscript,
    required double? newSegmentEndSeconds,
    required DateTime? segmentRecordedAt,
    required double? newFileSizeKB,
  }) =>
      (super.noSuchMethod(
            Invocation.method(#appendToRecording, [], {
              #recordingId: recordingId,
              #newTranscript: newTranscript,
              #newSegmentEndSeconds: newSegmentEndSeconds,
              #segmentRecordedAt: segmentRecordedAt,
              #newFileSizeKB: newFileSizeKB,
            }),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> deleteRecording(String? recordingId) =>
      (super.noSuchMethod(
            Invocation.method(#deleteRecording, [recordingId]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<_i8.Recording?> getRecording(String? recordingId) =>
      (super.noSuchMethod(
            Invocation.method(#getRecording, [recordingId]),
            returnValue: _i3.Future<_i8.Recording?>.value(),
          )
          as _i3.Future<_i8.Recording?>);

  @override
  _i3.Future<void> clearAllRecordings() =>
      (super.noSuchMethod(
            Invocation.method(#clearAllRecordings, []),
            returnValue: _i3.Future<void>.value(),
            returnValueForMissingStub: _i3.Future<void>.value(),
          )
          as _i3.Future<void>);

  @override
  _i3.Future<String?> getOpenAIApiKey() =>
      (super.noSuchMethod(
            Invocation.method(#getOpenAIApiKey, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> saveOpenAIApiKey(String? apiKey) =>
      (super.noSuchMethod(
            Invocation.method(#saveOpenAIApiKey, [apiKey]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> deleteOpenAIApiKey() =>
      (super.noSuchMethod(
            Invocation.method(#deleteOpenAIApiKey, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> hasOpenAIApiKey() =>
      (super.noSuchMethod(
            Invocation.method(#hasOpenAIApiKey, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getGeminiApiKey() =>
      (super.noSuchMethod(
            Invocation.method(#getGeminiApiKey, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> saveGeminiApiKey(String? apiKey) =>
      (super.noSuchMethod(
            Invocation.method(#saveGeminiApiKey, [apiKey]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> deleteGeminiApiKey() =>
      (super.noSuchMethod(
            Invocation.method(#deleteGeminiApiKey, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> hasGeminiApiKey() =>
      (super.noSuchMethod(
            Invocation.method(#hasGeminiApiKey, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String> getTranscriptionMode() =>
      (super.noSuchMethod(
            Invocation.method(#getTranscriptionMode, []),
            returnValue: _i3.Future<String>.value(
              _i10.dummyValue<String>(
                this,
                Invocation.method(#getTranscriptionMode, []),
              ),
            ),
          )
          as _i3.Future<String>);

  @override
  _i3.Future<bool> setTranscriptionMode(String? mode) =>
      (super.noSuchMethod(
            Invocation.method(#setTranscriptionMode, [mode]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getPreferredWhisperModel() =>
      (super.noSuchMethod(
            Invocation.method(#getPreferredWhisperModel, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> setPreferredWhisperModel(String? modelName) =>
      (super.noSuchMethod(
            Invocation.method(#setPreferredWhisperModel, [modelName]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> getAutoTranscribe() =>
      (super.noSuchMethod(
            Invocation.method(#getAutoTranscribe, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> setAutoTranscribe(bool? enabled) =>
      (super.noSuchMethod(
            Invocation.method(#setAutoTranscribe, [enabled]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> getAutoPauseRecording() =>
      (super.noSuchMethod(
            Invocation.method(#getAutoPauseRecording, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> setAutoPauseRecording(bool? enabled) =>
      (super.noSuchMethod(
            Invocation.method(#setAutoPauseRecording, [enabled]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> getAudioDebugOverlay() =>
      (super.noSuchMethod(
            Invocation.method(#getAudioDebugOverlay, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> setAudioDebugOverlay(bool? enabled) =>
      (super.noSuchMethod(
            Invocation.method(#setAudioDebugOverlay, [enabled]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String> getTitleGenerationMode() =>
      (super.noSuchMethod(
            Invocation.method(#getTitleGenerationMode, []),
            returnValue: _i3.Future<String>.value(
              _i10.dummyValue<String>(
                this,
                Invocation.method(#getTitleGenerationMode, []),
              ),
            ),
          )
          as _i3.Future<String>);

  @override
  _i3.Future<bool> setTitleGenerationMode(String? mode) =>
      (super.noSuchMethod(
            Invocation.method(#setTitleGenerationMode, [mode]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getPreferredGemmaModel() =>
      (super.noSuchMethod(
            Invocation.method(#getPreferredGemmaModel, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> setPreferredGemmaModel(String? modelName) =>
      (super.noSuchMethod(
            Invocation.method(#setPreferredGemmaModel, [modelName]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getOllamaModel() =>
      (super.noSuchMethod(
            Invocation.method(#getOllamaModel, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> setOllamaModel(String? modelName) =>
      (super.noSuchMethod(
            Invocation.method(#setOllamaModel, [modelName]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getPreferredSmolLMModel() =>
      (super.noSuchMethod(
            Invocation.method(#getPreferredSmolLMModel, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> setPreferredSmolLMModel(String? modelName) =>
      (super.noSuchMethod(
            Invocation.method(#setPreferredSmolLMModel, [modelName]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getHuggingFaceToken() =>
      (super.noSuchMethod(
            Invocation.method(#getHuggingFaceToken, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> saveHuggingFaceToken(String? token) =>
      (super.noSuchMethod(
            Invocation.method(#saveHuggingFaceToken, [token]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> deleteHuggingFaceToken() =>
      (super.noSuchMethod(
            Invocation.method(#deleteHuggingFaceToken, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> hasHuggingFaceToken() =>
      (super.noSuchMethod(
            Invocation.method(#hasHuggingFaceToken, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getGitHubToken() =>
      (super.noSuchMethod(
            Invocation.method(#getGitHubToken, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> saveGitHubToken(String? token) =>
      (super.noSuchMethod(
            Invocation.method(#saveGitHubToken, [token]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> deleteGitHubToken() =>
      (super.noSuchMethod(
            Invocation.method(#deleteGitHubToken, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> hasGitHubToken() =>
      (super.noSuchMethod(
            Invocation.method(#hasGitHubToken, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getGitHubRefreshToken() =>
      (super.noSuchMethod(
            Invocation.method(#getGitHubRefreshToken, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> saveGitHubRefreshToken(String? refreshToken) =>
      (super.noSuchMethod(
            Invocation.method(#saveGitHubRefreshToken, [refreshToken]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<DateTime?> getGitHubTokenExpiresAt() =>
      (super.noSuchMethod(
            Invocation.method(#getGitHubTokenExpiresAt, []),
            returnValue: _i3.Future<DateTime?>.value(),
          )
          as _i3.Future<DateTime?>);

  @override
  _i3.Future<bool> saveGitHubTokenExpiresAt(DateTime? expiresAt) =>
      (super.noSuchMethod(
            Invocation.method(#saveGitHubTokenExpiresAt, [expiresAt]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<DateTime?> getGitHubRefreshTokenExpiresAt() =>
      (super.noSuchMethod(
            Invocation.method(#getGitHubRefreshTokenExpiresAt, []),
            returnValue: _i3.Future<DateTime?>.value(),
          )
          as _i3.Future<DateTime?>);

  @override
  _i3.Future<bool> saveGitHubRefreshTokenExpiresAt(DateTime? expiresAt) =>
      (super.noSuchMethod(
            Invocation.method(#saveGitHubRefreshTokenExpiresAt, [expiresAt]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<String?> getGitHubRepositoryUrl() =>
      (super.noSuchMethod(
            Invocation.method(#getGitHubRepositoryUrl, []),
            returnValue: _i3.Future<String?>.value(),
          )
          as _i3.Future<String?>);

  @override
  _i3.Future<bool> saveGitHubRepositoryUrl(String? url) =>
      (super.noSuchMethod(
            Invocation.method(#saveGitHubRepositoryUrl, [url]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> deleteGitHubRepositoryUrl() =>
      (super.noSuchMethod(
            Invocation.method(#deleteGitHubRepositoryUrl, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> isGitSyncEnabled() =>
      (super.noSuchMethod(
            Invocation.method(#isGitSyncEnabled, []),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);

  @override
  _i3.Future<bool> setGitSyncEnabled(bool? enabled) =>
      (super.noSuchMethod(
            Invocation.method(#setGitSyncEnabled, [enabled]),
            returnValue: _i3.Future<bool>.value(false),
          )
          as _i3.Future<bool>);
}

/// A class which mocks [ContentHasher].
///
/// See the documentation for Mockito's code generation for more information.
class MockContentHasher extends _i1.Mock implements _i11.ContentHasher {
  MockContentHasher() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String computeHash(_i8.Recording? recording) =>
      (super.noSuchMethod(
            Invocation.method(#computeHash, [recording]),
            returnValue: _i10.dummyValue<String>(
              this,
              Invocation.method(#computeHash, [recording]),
            ),
          )
          as String);

  @override
  String computeHashFromFields({
    required String? title,
    String? summary = '',
    String? context = '',
    List<String>? tags = const [],
    String? transcript = '',
  }) =>
      (super.noSuchMethod(
            Invocation.method(#computeHashFromFields, [], {
              #title: title,
              #summary: summary,
              #context: context,
              #tags: tags,
              #transcript: transcript,
            }),
            returnValue: _i10.dummyValue<String>(
              this,
              Invocation.method(#computeHashFromFields, [], {
                #title: title,
                #summary: summary,
                #context: context,
                #tags: tags,
                #transcript: transcript,
              }),
            ),
          )
          as String);
}
